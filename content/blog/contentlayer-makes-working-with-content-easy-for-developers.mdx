---
title: Contentlayer Makes Working with Content Easy for Developers
excerpt: TODO Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua.
date: 2022-04-08
authors: Johannes Schickling
---

# The Modern Approach: Content as Data

How we handle content for the web [has evolved significantly](/blog/working-with-content-is-hard-for-developers) over the past three decades. The pattern from frameworks emerging today is to bring no opinion about how you handle content.

![Modern Meta Frameworks - Content as Data, Unprescribed](https://i.imgur.com/ulSFruZ.png)

Tools like Next.js, Remix, SvelteKit, Astro, and others make no inference as to where your content is stored or how it is processed.

Instead, they focus their energy on providing a refined page routing and rendering system. Using Node.js, developers can process content however they want and send it as data to their pages, which are rendered using a component-based framework, like React, Vue, or Svelte.

## Content as Data is Better. But it’s Hard.

This _content as data_ approach has been a _huge_ improvement over the limitations and challenges of previous attempts to improve the developer experience when working with content.

But it’s still hard.

While it’s nice to be able to work the way you want, it’s not so great to write low-level content-processing logic when you could move faster if that work was done for you, and you could spend more time on the business logic.

### An Example with Next.js + Markdown

For example, if you built a website using Next.js with local markdown files as your content source, you’d have to put a mechanism in place that converted those markdown files to data that you could feed into Next.js pages.

![Modern Meta Frameworks - Content as Data, Unprescribed](https://i.imgur.com/4uxWcuc.png)

Doing that on its own doesn’t sound like a lot of work, but it gets complicated fast. Consider that if you _really_ wanted to have the optimal developer experience, you’d have to do the following:

- Write markdown processing logic, including working with content-processing libraries and their plugins. This is a lot of base-level logic and adds a number of dependencies to your project.
- Cache processed data. _Caching is hard_. _Not caching_ degrades the developer experience.
- Incrementally regenerate only the content you changed to optimize rebuild/reload performance.
- Account for rich and complex content associations, so that objects can live as individual content files but be embedded as necessary when used as data.
- For some frameworks, like Next.js, pages are not live-reloaded automatically when editing markdown content. That’s another mechanism to build.
- If you want to work with TypeScript and have strongly-typed data, you must generate those types manually (or build a thing that does it automatically).
- Implement content validations, or build an abstracted system that accepts validation settings through configuration.

That’s _a lot_ of work.

# Contentlayer Makes Content Easy

And that’s [why we built Contentlayer](/blog/working-with-content-is-hard-for-developers). **Contentlayer makes working with content easy.**

![Contentlayer - Content as Data, Made Easy for Developers](https://i.imgur.com/RsprRtN.png)

## How Contentlayer Works

Working with Contentlayer is a three-step process:

1. Configure your content source within a Contentlayer configuration file.

   ```jsx
   import { defineDocumentType, makeSource } from 'contentlayer/source-files'

   const Post = defineDocumentType(() => ({
     name: 'Post',
     filePathPattern: `**/*.md`,
     fields: {
       title: { type: 'string', required: true },
       date: { type: 'date', required: true },
     },
     computedFields: {
       urlPath: {
         type: 'string',
         resolve: (doc) => `/posts/${doc._raw.flattenedPath}`,
       },
     },
   }))

   export default makeSource({
     contentDirPath: 'posts',
     documentTypes: [Post],
   })
   ```

2. Run the build. This can be done independently, or by hooking into framework server/build processes.

   ![Contentlayer - Data Transformation](https://i.imgur.com/3Iqt1sP.png)

3. Use `import` to work with your content, just as you would any other data in your application.

   ```jsx
   import { allPages, type Page } from 'contentlayer/generated'

   export async function getStaticPaths() {
     const paths = allPages.map((page) => page.urlPath)
     return { paths }
   }

   export async function getStaticProps({ params }) {
     const page = allPages.find((page) => page.UrlPath === params.slug)

     return { props: { page } }
   }

   export default function Page({ page }: { page: Page }) {
     return (
       <div>
         <h1>{page.title}</h1>
         <div dangerouslySetInnerHTML={{ __html: page.body.html }} />
       </div>
     )
   }
   ```

### See it in Action

To take a deeper dive, here’s what it looks like to use Contentlayer to load local markdown files into a simple Next.js application with TypeScript.

_TODO: Rather than spelling out the whole tutorial here, we link to a video that walks through the tutorial example, but using TypeScript._

### Try it Yourself

Take a look around a working example. Notice the following:

- The content is generated into a `.contentlayer/generated` directory that includes JSON content caches, exported collections of data, and automatically-generated types.
- The `pages/[[...slug]].tsx` page brings in the content directly, manipulates it as needed, and passes it onto the page component.

Try it! Make a change to one of the markdown files in the `content` directory. Notice that the content in the browser is automatically refreshed (quickly) and the JSON cache is updated for that piece of content.

<Playground githubRepo="contentlayerdev/next-contentlayer-example/tree/stackblitz-demo" openFile="posts/change-me.md" />

## Contentlayer is Fast at Every Stage of a Project

![Contentlayer is fast](https://i.imgur.com/CgyzAtU.png)

Contentlayer isn’t just convenient and built to improve development experience. It’s also _fast_. Contentlayer provides performance benefits when you:

- **Build:** The server boots quickly, content is incrementally regenerated, and live reloading unlocked.
- **Test:** Because builds are faster, CI and CD finish quicker, which means your content gets into production sooner.
- **Deploy:** More processing is done at build time, including rendering markdown, minimizing the work done on the client. This improves your Lighthouse scores and makes your site faster for your users.

## Built to Serve Most Projects

![Contentlayer - Content as Data, Made Easy for Developers](https://i.imgur.com/HwBRywW.png)

As we’ve seen, Contentlayer tends to work best alongside frameworks with an open content model. We’ve focused on Next.js up until this point, but plan to investigate support for Remix, SvelteKit, Nuxt, and more.

Beyond the framework, Contentlayer can stand up to complex content structures, while also serving projects at every stage. It’s simple enough to get started that you’d find great benefit in working with Contentlayer for your personal site or blog.

And it _really_ starts to feel like the right decision as content structures become more nested or complex, like in typical documentation sites. And it can continue to scale with any site as its complexity grows.

When starting a project with opinionated content tooling, there is always a risk of outgrowing those opinions and needing to switch to something more flexible. Conentlayer makes the flexibility of modern open content frameworks accessible to projects of any size.

# The Future of Content

And we’re just getting started.

![contentlayer - The Future of Content](https://i.imgur.com/3sSqu69.png)

## Contentlayer’s Roadmap

We will continue to add new content sources — Contentful is experimental, with Notion is coming up quickly behind it — and investigate fully supporting additional modern frameworks. We’ll also be giving much attention to image processing.

[The roadmap](https://www.contentlayer.dev/docs/other/roadmap) is being shaped by our open-source community that has grown organically and will continue to grow with your involvement.

## Join the Contentlayer Community

Become part of the Contentlayer journey by:

- Following [the tutorial](https://www.contentlayer.dev/docs/getting-started) and bringing Contentlayer into your project.
- Looking through [examples](https://www.contentlayer.dev/docs/other/examples) and other open-source projects created with Contentlayer.
- Joining our [Discord community](https://discord.gg/rytFErsARm).

## A Note to our Contributors

It took a lot of effort to get to this point. Big thanks to [Stackbit](https://www.stackbit.com/), who has sponsored this project from the beginning.

We also owe a big thanks to the following contributors:

- Other contributors, including ...
- Lukas, for putting the finishing touches on the website so we could write this blog post.
- Those already using Contentlayer in their projects, including ...
- All of our community members who have given us early feedback and helped shape the project.

---

Contentlayer is here to help you work easily and consistently with content in your projects without injecting restricting opinions on the way you work.

Thank you for your support!

Johannes Schickling
